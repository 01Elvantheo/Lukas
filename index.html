<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flappy Kepala ðŸ¤£</title>

  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
      touch-action: manipulation;
    }

    canvas {
      border: 4px solid white;
      border-radius: 12px;
      display: block;
      background: skyblue;
    }
  </style>
</head>

<body>
<canvas id="game" width="450" height="650"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ==========================
// GAME STATE
// ==========================
let state = "start"; // start, play, gameover
let score = 0;
let highscore = parseInt(localStorage.getItem("highscore_flappy_kepala")) || 0;

// ==========================
// SHAKE EFFECT
// ==========================
let shakeTime = 0;
let shakeStrength = 10;

// ==========================
// PLAYER
// ==========================
const player = {
  x: 110,
  y: 260,
  w: 65,
  h: 65,
  vel: 0,
  gravity: 0.55,
  jump: -10
};

// ==========================
// PIPES
// ==========================
const pipeWidth = 80;
const pipeGap = 190;
const pipeSpeed = 3.2;
let pipes = [];

// ==========================
// GROUND
// ==========================
const groundHeight = 110;
let groundOffset = 0;

// ==========================
// CLOUDS
// ==========================
let clouds = [];
for (let i = 0; i < 7; i++) {
  clouds.push({
    x: Math.random() * canvas.width,
    y: Math.random() * 220 + 20,
    speed: 0.4 + Math.random() * 0.7,
    size: 45 + Math.random() * 55
  });
}

// ==========================
// LOAD HEAD IMAGE
// ==========================
const kepalaImg = new Image();
kepalaImg.src = "./kepala.png";

let kepalaReady = false;

kepalaImg.onload = () => kepalaReady = true;
kepalaImg.onerror = () => {
  kepalaReady = false;
  console.log("ERROR: kepala.png tidak ditemukan.");
};

// ==========================
// HELPERS
// ==========================
function rectCollide(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

function spawnPipe() {
  const minHeight = 80;
  const maxHeight = canvas.height - groundHeight - pipeGap - 80;
  const topHeight = Math.floor(Math.random() * (maxHeight - minHeight)) + minHeight;

  pipes.push({
    x: canvas.width + 50,
    top: topHeight,
    bottom: topHeight + pipeGap,
    passed: false
  });
}

function resetGame() {
  score = 0;
  player.y = 260;
  player.vel = 0;
  pipes = [];
  groundOffset = 0;

  spawnPipe();
}

// ==========================
// DRAW FUNCTIONS
// ==========================
function drawHeadCircle(x, y, size) {
  ctx.save();

  ctx.beginPath();
  ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();

  if (kepalaReady) {
    ctx.drawImage(kepalaImg, x, y, size, size);
  } else {
    ctx.fillStyle = "red";
    ctx.fillRect(x, y, size, size);

    ctx.fillStyle = "white";
    ctx.font = "12px Arial";
    ctx.fillText("kepala.png?", x + 5, y + 35);
  }

  ctx.restore();

  ctx.beginPath();
  ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
  ctx.strokeStyle = "black";
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawPipe3D(x, y, w, h) {
  let grad = ctx.createLinearGradient(x, 0, x + w, 0);
  grad.addColorStop(0, "#0b5d0b");
  grad.addColorStop(0.3, "#2dff2d");
  grad.addColorStop(0.6, "#0f8f0f");
  grad.addColorStop(1, "#064006");

  ctx.fillStyle = grad;
  ctx.fillRect(x, y, w, h);

  ctx.fillStyle = "rgba(255,255,255,0.25)";
  ctx.fillRect(x + 10, y + 5, 10, h - 10);

  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(x + w - 12, y + 5, 12, h - 10);

  ctx.strokeStyle = "rgba(0,0,0,0.65)";
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);
}

function drawPipeCap(x, y, w, isTop) {
  let capHeight = 28;

  let grad = ctx.createLinearGradient(x, 0, x + w, 0);
  grad.addColorStop(0, "#0b5d0b");
  grad.addColorStop(0.3, "#2dff2d");
  grad.addColorStop(0.6, "#0f8f0f");
  grad.addColorStop(1, "#064006");

  ctx.fillStyle = grad;
  ctx.strokeStyle = "rgba(0,0,0,0.75)";
  ctx.lineWidth = 2;

  if (isTop) {
    ctx.fillRect(x - 8, y - capHeight, w + 16, capHeight);
    ctx.strokeRect(x - 8, y - capHeight, w + 16, capHeight);
  } else {
    ctx.fillRect(x - 8, y, w + 16, capHeight);
    ctx.strokeRect(x - 8, y, w + 16, capHeight);
  }
}

function drawCloud(x, y, size) {
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.beginPath();
  ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
  ctx.arc(x + size * 0.45, y - size * 0.2, size * 0.5, 0, Math.PI * 2);
  ctx.arc(x + size * 0.9, y, size * 0.4, 0, Math.PI * 2);
  ctx.arc(x + size * 0.45, y + size * 0.2, size * 0.45, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();
}

function drawGround() {
  let groundY = canvas.height - groundHeight;

  ctx.fillStyle = "#caa76d";
  ctx.fillRect(0, groundY, canvas.width, groundHeight);

  ctx.fillStyle = "#3cae2a";
  ctx.fillRect(0, groundY, canvas.width, 18);

  for (let i = -50; i < canvas.width + 100; i += 50) {
    ctx.fillStyle = "rgba(120,80,40,0.35)";
    ctx.beginPath();
    ctx.ellipse(i + groundOffset, groundY + 55, 18, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(80,50,20,0.25)";
    ctx.beginPath();
    ctx.ellipse(i + 20 + groundOffset, groundY + 85, 14, 8, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.strokeStyle = "rgba(0,0,0,0.3)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(canvas.width, groundY);
  ctx.stroke();
}

function drawStartUI() {
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.textAlign = "center";
  ctx.fillStyle = "white";

  ctx.font = "bold 52px Arial";
  ctx.fillText("FLAPPY", canvas.width/2, 200);

  ctx.font = "bold 48px Arial";
  ctx.fillText("KEPALA", canvas.width/2, 260);

  ctx.font = "20px Arial";
  ctx.fillText("Highscore: " + highscore, canvas.width/2, 315);

  let blink = Math.sin(Date.now() / 250) > 0;
  if (blink) {
    ctx.font = "22px Arial";
    ctx.fillText("TAP / SPACE TO START", canvas.width/2, 380);
  }

  ctx.font = "16px Arial";
  ctx.fillText("Klik layar buat loncat", canvas.width/2, 430);

  ctx.textAlign = "left";
}

function drawGameOverUI() {
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "white";
  ctx.textAlign = "center";

  ctx.font = "bold 50px Arial";
  ctx.fillText("GAME OVER", canvas.width/2, 250);

  ctx.font = "24px Arial";
  ctx.fillText("Score: " + score, canvas.width/2, 310);

  ctx.font = "20px Arial";
  ctx.fillText("Highscore: " + highscore, canvas.width/2, 350);

  let blink = Math.sin(Date.now() / 250) > 0;
  if (blink) {
    ctx.font = "20px Arial";
    ctx.fillText("TAP TO RESTART", canvas.width/2, 410);
  }

  ctx.textAlign = "left";
}

// ==========================
// INPUT
// ==========================
function jumpOrRestart() {
  if (state === "start") {
    resetGame();
    state = "play";
    player.vel = player.jump;
    return;
  }

  if (state === "play") {
    player.vel = player.jump;
    return;
  }

  if (state === "gameover") {
    state = "start";
    return;
  }
}

document.addEventListener("keydown", (e) => {
  if (e.code === "Space") jumpOrRestart();

  if (e.code === "KeyR") {
    if (state === "gameover") state = "start";
  }
});

// Mobile friendly
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  jumpOrRestart();
}, { passive: false });

canvas.addEventListener("click", () => jumpOrRestart());

// ==========================
// MAIN LOOP
// ==========================
function update() {
  let shakeX = 0;
  let shakeY = 0;

  if (shakeTime > 0) {
    shakeX = (Math.random() - 0.5) * shakeStrength;
    shakeY = (Math.random() - 0.5) * shakeStrength;
    shakeTime--;
  }

  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Sky gradient
  let skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
  skyGrad.addColorStop(0, "#77c9ff");
  skyGrad.addColorStop(1, "#d9f4ff");

  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Clouds always move
  clouds.forEach(cloud => {
    cloud.x -= cloud.speed;

    if (cloud.x < -250) {
      cloud.x = canvas.width + 250;
      cloud.y = Math.random() * 220 + 20;
      cloud.size = 45 + Math.random() * 55;
      cloud.speed = 0.4 + Math.random() * 0.7;
    }

    drawCloud(cloud.x, cloud.y, cloud.size);
  });

  // Play updates
  if (state === "play") {
    player.vel += player.gravity;
    player.y += player.vel;

    groundOffset -= 2;
    if (groundOffset < -50) groundOffset = 0;

    pipes.forEach(pipe => pipe.x -= pipeSpeed);

    if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 250) {
      spawnPipe();
    }

    pipes = pipes.filter(pipe => pipe.x + pipeWidth > -80);
  }

  // Draw pipes
  pipes.forEach(pipe => {
    drawPipe3D(pipe.x, 0, pipeWidth, pipe.top);
    drawPipeCap(pipe.x, pipe.top, pipeWidth, true);

    drawPipe3D(pipe.x, pipe.bottom, pipeWidth, canvas.height - groundHeight - pipe.bottom);
    drawPipeCap(pipe.x, pipe.bottom, pipeWidth, false);

    if (state === "play") {
      const playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};

      const topRect = {x: pipe.x, y: 0, w: pipeWidth, h: pipe.top};
      const bottomRect = {
        x: pipe.x,
        y: pipe.bottom,
        w: pipeWidth,
        h: canvas.height - groundHeight - pipe.bottom
      };

      if (rectCollide(playerRect, topRect) || rectCollide(playerRect, bottomRect)) {
        state = "gameover";
        shakeTime = 25;
      }

      if (!pipe.passed && pipe.x + pipeWidth < player.x) {
        pipe.passed = true;
        score++;

        if (score > highscore) {
          highscore = score;
          localStorage.setItem("highscore_flappy_kepala", highscore);
        }
      }
    }
  });

  drawGround();
  drawHeadCircle(player.x, player.y, player.w);

  // Ground collision
  if (state === "play") {
    if (player.y + player.h > canvas.height - groundHeight) {
      state = "gameover";
      shakeTime = 25;
    }

    if (player.y < 0) {
      player.y = 0;
      player.vel = 0;
    }
  }

  // Score UI
  if (state === "play") {
    ctx.fillStyle = "white";
    ctx.font = "24px Arial";
    ctx.fillText("Score: " + score, 20, 40);

    ctx.font = "18px Arial";
    ctx.fillText("Highscore: " + highscore, 20, 65);
  }

  // Overlay UI
  if (state === "start") drawStartUI();
  if (state === "gameover") drawGameOverUI();

  ctx.restore();
  requestAnimationFrame(update);
}

update();
</script>

</body>
</html>
